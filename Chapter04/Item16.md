## Item 16 : 계승하는 대신 구성하라

> 계승 => 상속

<br/>
<br/>

### 요약

**상속(계승)은 강력한 도구지만 캡슐화 원칙을 침해하므로 문제를 발생시킬 소지가 있다.**

**상위 클래스와 하위클래스 사이에 IS-A 관계가 있을 때만 사용하는 것이 좋다.**

**IS-A 관계라도 서로 다른 패키지에 있거나 상속을 고려해 만들어진 상위클래스가 아니라면 하위 클래스는 깨지기 쉽다.**

**이런문제 때문에 구성과 전달 기법을 사용하는 것이 좋다.**

<br/>
<br/>
<br/>

**계승은 캡슐화 원칙을 위반한다.**

하위 클래스가 정상 동작하기 위해서는 상위 클래스의 구현에 의존할 수 밖에 없다.

상위 클래스 작성자가 계승을 고려해 클래스를 설계하고 문서까지 만들어 놓지 않았다면,

하위 클래스는 상위 클래스의 변화에 발맞춰 진화해야 한다.

<BR/>

**B는 A와 "IS-A" 관계가 성립할 때 A를 계승하자.**

그렇지 않다면 A를 계승하면 안된다.

B안에 A객체를 참조하는 priate 필드를 두고, B에는 더 작고 간단한 API를 구현해야 한다.
A는 B의 핵심적인 부분이 아니며, B의 구현 세부사항에 불과하다.

```java
//계승
public void A extends B {

}
```

```java
//구성
public void A {
  private B = new B();
}
```

<BR/>

자바 플랫폼 라이브러리에는 이 원칙을 위반하는 사례들이 많다.

예를 들어 스택은 벡터가 아니므로 계승하면 안된다.

구성기법이 적절한 곳에 계승을 사용하면 구현 세부사항이 쓸데없이 노출된다.

원래 구현에서 벗어날 수 없게 되며, 클랫의 성능을 개선하기 어려워진다.

가장 심각한 문제는 클라이언트가 상위 클래스 상태를 직접 변경하여 하위 클래스의 불변식을 깰 수 있다는 것이다.





## TODO p114~p115 wrapper class
장식자패턴
